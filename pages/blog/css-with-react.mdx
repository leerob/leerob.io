---
title: 'How Should I Style My React Application?'
publishedAt: '2020-09-15'
summary: 'TODO'
image: '/static/images/css-with-react/banner.png'
---

The React ecosystem is unopinionated. **This is both it's greatest strength and weakness.**

Over the years, I tried about seven different ways to style my React applications. Each solution has their own pros and cons.
Most comparions between CSS / CSS-in-JS and their ecosystem fail to consider the scale of the application and the size of the team.

Let's go on a journey and learn how CSS has evolved to bring us to its current state. I'll share my journey and then discuss pros / cons of
different approaches for styling React applications after. I'll try to make this comparison as unopinionated as possible.

## Vanilla CSS

Like most, I started web development with vanilla CSS. You have to learn the basics first. All we need is an HTML and CSS file.

```html:index.html
<h1 class="header">Welcome</h1>
```

```css:index.css
.header {
  font-size: 32px;
}
```

As I built more applications, I began to understand some of the drawbacks.

- **Problem.**Â todo
- **Specificity.**Â Since CSS has a global namespace, you can unintentionally target too many elements.
- **Colocation.Â **It's hard to modularize your CSS, which makes it difficult to delete code safely.

At this point, I was introduced to CSS pre-processors.

## Saas

Saas, one of the most popular, allowed you to write more reusable, maintainable CSS. Some of the most popular features are variables, mixins, and modules.

- **Variables.**Â I want to define global values once and share them throughout my stylesheets.
- **Mixins.**Â I want to reuse particular snippets of CSS.
- **Modules.**Â I want to split up my CSS files for a more maintainable codebase.

```scss:_base.scss
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
```

```scss:_header.scss
@use 'base';

.header {
  font-size: 32px;
}
```

Sass helped me write more modular, reusable CSS â€“ at least, for a while. Over time, I ran into new issues.

- **Naming.**Â As your CSS grows, it's easy to have class names get out of hand.
- **Browser support.**Â Certain features aren't supported across all browsers and require "vendor prefixes" like `-moz` (Firefox), `-webkit` (Safari), and `-ms` (Internet Explorer).

To solve naming, I started to adoptÂ [BEM](http://getbem.com/introduction/). Block Element Modifier is a methodology that helps you to create reusable components and code sharing in front-end development.

```html
<button class="button">Cancel</button>
<button class="button button--primary">Submit</button>
```

```css
.button {
  color: black;
  background-color: gray;
}

.button--state-success {
  color: white;
  background-color: green;
}
```

Naming conventions helped but didn't fix the root cause:Â **naming is hard**.
For browser support, it's possible to set up your Sass toolchain with a tool likeÂ [autoprefixer](https://css-tricks.com/autoprefixer/)Â to handle vendor prefixes. However, around this time, I started using React.

Once I started using component-based frameworks like React, I started exploring CSS-in-JS.

## CSS-in-JS

My first adventure: building a component library with styled-components. At first, CSS-in-JS solved all my problems.

- **SpecificityÂ **is solved by auto-generated class names.
- **ColocationÂ **is solved by putting CSS directly with the component, making it easy to delete code.
- **Browser support**Â is solved by having autoprefixer built-in.
- **Variables**Â are solved by creating a global theme.

As the component library grew, I began to explore styled-system and Theme UI. These were more structured approaches to scaling CSS-in-JS and helping enforce a design system. Plus, it helped solveÂ **naming**. Trying to scale `styled-components` alone in a large application made me get _really_ creative with names. You can only have so many container, wrapper, layout things.

```js
// Bad
const HomeContainerWrapper = styled.div`
Â  Â padding: 8px;
Â  Â font-weight: bold;
Â  Â color: white;
Â  Â background: blue;
`;

<HomeContainerWrapper>
Â Â Hello
</HomeContainerWrapper>

// Good
<Box
Â Â padding={3}
Â Â fontWeight='bold'
Â Â color='white'
Â Â bg='blue'
>
Â Â Hello
</Box>
```

Now, I know what you're thinking. Inline styles ðŸ¤®. I'll admit, I wasn't sold at first. But it grew on me. And that brings us to now.

## Current State

I've recently been working with [CSS Modules](https://github.com/css-modules/css-modules) and [Tailwind CSS](https://tailwindcss.com/).
Both of these approaches to styling React applications have prompted me to step back and evaluate the ecosystem.

I've tried to summarize and collect pros and cons for various approaches of styling your React application. The choice that's best for you
likely depends on:

- Your experience (stick with what you know)
- Your team
- The size of your application
- What you're trying to build

## Pros and Cons

### Vanilla CSS

import ProsCard from '../../components/ProsCard';
import ConsCard from '../../components/ConsCard';

<ProsCard
  title="vanilla CSS"
  pros={['No toolchain necessary. Works with every browser & language.']}
/>

<ConsCard
  title="vanilla CSS"
  cons={['Not a viable option for large web applications.']}
/>

### CSS Modules

[CSS Modules](https://github.com/css-modules/css-modules) would be my choice for smaller teams that don't need to share
components across applications.

[Next.js](https://nextjs.org) has support for CSS Modules, which means you don't have to worry about setting up [Webpack]().
It also sets up [autoprefixer](https://css-tricks.com/autoprefixer/), which makes CSS Modules an attractive alternative to CSS-in-JS in some cases.

<ProsCard
  title="CSS modules"
  pros={[
    'Class names are scoped to the corresponding component.',
    'CSS variables allow you to reuse values.',
    'Your application can work without JavaScript.',
    'Lowest barrier to entry.',
    'Works with any language.'
  ]}
/>

<ConsCard
  title="CSS modules"
  cons={[
    'Requires confguring a toolchain like Webpack.',
    'Distribution is hard.',
    'Lack of nesting and CSS linting.',
    `Some argue there's more context switching between different files`
  ]}
/>

### CSS-in-JS

There's many different CSS-in-JS libraries. The two most popular are [styled-components](https://styled-components.com/) and [Emotion](https://emotion.sh/docs/introduction).

There's also zero-runtime solutions like [Linaria](https://github.com/callstack/linaria), where CSS is extracted to CSS files at build-time.
To see comparisions between different libraries, see [CSS-in-JS benchmarks.](https://github.com/A-gambit/CSS-IN-JS-Benchmarks)

<ProsCard
  title="CSS-in-JS"
  pros={[
    'Easy to distribute as reusable components on NPM.',
    'You can take advatange of anything in the JavaScript ecosystem.',
    'Styles are colocated with components, making it easy to delete code.',
    'Easy to provide multiple themes.'
  ]}
/>

<ConsCard
  title="CSS-in-JS"
  cons={[
    'Requires confguring a toolchain like Webpack.',
    'Some argue it breaks separation of concerns.',
    'Difficult for libraries, since all consumers must use the same CSS-in-JS solution.'
  ]}
/>

### Theme UI / Styled System

Both [Theme UI](https://theme-ui.com) and [styled-system](https://styled-system.com/) abide by the [System UI theme specification](https://system-ui.com/).
The intent behind this specification is to help make UI components, libraries, and tools as interoperable as possible.

The primary use case for these libraries is implenting a component library and design system.
One of my favorite libraries is [Chakra UI](https://next.chakra-ui.com/).

<ProsCard
  title="Theme UI / styled-system"
  pros={[
    'Great for component libraries. Many are built on top of this.',
    'Allows you to easily enforce a design system.',
    'Spend less time trying to name components',
    'All libraries that follow System UI spec should be interoperable.'
  ]}
/>

<ConsCard
  title="Theme UI / styled-system"
  cons={[
    'You dislike providing styles as props.',
    'Some argue it breaks separation of concerns.'
  ]}
/>

### Tailwind CSS

[Tailwind CSS](https://tailwindcss.com/) has been rapidly growing in popularity. Many people are fed up with the bloat of utility frameworks like
[Bootstrap](https://getbootstrap.com/) and want an alternative. Tailwind provides an impressive developer experience with a refined API.

With the combination of [Tailwind UI](https://tailwindui.com/), you can easily build extensible, well-designed applications.

<ProsCard
  title="Tailwind"
  pros={[
    'Utility classes allow you to never leave your HTML.',
    'Allows you to easily enforce a design system.',
    'Spend less time trying to name components',
    'All libraries that follow System UI spec should be interoperable.'
  ]}
/>

<ConsCard
  title="Tailwind"
  cons={[
    'You can have really, really long class names.',
    'To use effectively, requires toolchain with PurgeCSS.',
    'You need to learn Tailwind syntax, which is slighty different than standard CSS.'
  ]}
/>

## Resources

- [What are CSS Modules and why do we need them?](https://css-tricks.com/css-modules-part-1-need/)
- [The Cost of JavaScript in 2019](https://v8.dev/blog/cost-of-javascript-2019)
- [CSS-in-JS Benchmarks](https://github.com/A-gambit/CSS-IN-JS-Benchmarks)
- [Refactoring an alert component from CSS to CSS-in-JS](https://alert-refactor.netlify.app/)
- [Why I Write CSS in JavaScript](https://mxstbr.com/thoughts/css-in-js)
- [Two Steps Forward, One Step Back](https://jxnblk.com/blog/two-steps-forward/)
